<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">

  <meta name="generator" content="Hugo 0.68.3" />
  <link rel="canonical" href="http://www.tritsch.org/post/2008-08-12-embedded-software-engineering-can-we/">

  

  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#000000">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="theme-color" content="#ffffff">

  <link rel="stylesheet" type="text/css" href="http://www.tritsch.org/css/paper.css">

  
  
  <link rel="stylesheet" type="text/css" href="http://www.tritsch.org/css/custom.css">

  
  
  <title>Embedded Software Engineering - Can we avoid another software crisis | innolocity.org/tedn.life</title>
</head>
  <body>
    <div class="container paper">
      <nav class="border split-nav">
  <div class="nav-brand">
    <h3><a href="/">innolocity.org/tedn.life</a></h3>
  </div>
  <div class="collapsible">
    <input id="collapsible1" type="checkbox" name="collapsible1">
    <button>
    <label for="collapsible1">
        <div class="bar1"></div>
        <div class="bar2"></div>
        <div class="bar3"></div>
      </label>
    </button>
    <div class="collapsible-body">
      <ul class="inline">
      
      </ul>
    </div>
  </div>
</nav>
      <main>
        

<h1 class="post-title">Embedded Software Engineering - Can we avoid another software crisis</h1>


<strong>Publish date: </strong>Aug 12, 2008
<br>



  




The term "<a href="http://en.wikipedia.org/wiki/Software_crisis">software crisis</a>" was coined 1968  by F.L. Bauer during the first NATO Software Engineering Conference  in Garmisch, Germany and was used by Dijkstra in his very famous lecture on "The humble programmer":<br /><br /> <span style="font-style: italic;">    [The major cause of the software crisis is] that the machines have become several orders of magnitude more powerful! To put it quite bluntly: as long as there were no machines, programming was no problem at all; when we had a few weak computers, programming became a mild problem, and now we have gigantic computers, programming has become an equally gigantic problem. </span><br /><br />             â€“ <cite>Edsger Dijkstra, The Humble Programmer<br /></cite><br />Right now there are lots of people who are saying two things: First, embedded devices and embedded software will change and transform our way of life in a similar or even stronger way than the arrival of the internet and second, the resulting software engineering challenges are huge.

<br /><br />There are a lot of drivers/trends behind this, but two of the more critical ones are the <a href="http://www.sdtimes.com/SearchResult/31938">arrival of multi-core processor architectures</a> for embedded devices and the resulting increase in processing power that comes with it (see quote above :)). And secondly the increasing demand to make embedded devices talk to each other (e.g. make Electronic Control Units (ECUs) on the car talk to each other and then make cars talk to each other).<br /><br />The lack of abstraction that we have in embedded software engineering makes more than 50% of all embedded software projects being later, over budget or not deliver on expectations.<br /><br />This sounds and looks like a first class  software (engineering) crisis. What do we do?<br /><br />Killing the problem with people (e.g. throw more people at the problem) is a very popular approach, especially with the emergence of cheap off-shore development centers in India and other places, but creates a huge liability, because over time it does not scale very well and the management and maintenance burden has the potential to become an even bigger problem.<br /><br />More thoughtful approaches first segment the embedded market from a requirements point of view and then look for much more systematic approaches to address the requirements in the given segment. One way to segment the market would be along the lines of the real-time requirements. Working assumption would be that there is a hard real-time market, a soft real-time market and an embedded market (no real-time requirements, but the software must run on devices with limited CPU and memory capabilities).<br /><br />The segment with the strongest growth is the last one. Addressing the software engineering issues in this segment will give us the biggest bang for the buck.<br /><br />One way to go about it is to use existing approaches that have (kind of) worked for the first two (real-time) segments and also use them in the embedded space, e.g. using integrated tool-chains to generate a lot of the source code (also known as Model-Driven Software-Development (MDSD)). This gives you good initial results in terms of productivity, but has the potential to create hard to maintain, monolithic, tightly-coupled monster systems.<br /><br />The most <a href="http://www.mil-embedded.com/articles/id/?3046">promising approach</a> right now is to introduce the idea of Software Product Lines (SPLs) to the domain of embedded software engineering and combine it with MDSD. This will give you the productivity gains you are looking for, but will also allow you to enforce a/the necessary level of reuse to ensure the long-term maintainability of the system.<br /><br />In that context abstractions become pivotal. Without abstractions there is no way to create good boundaries for reuse. The first level of abstraction is the operating system and here is good news, because more and more embedded systems are based on standard operating systems (e.g. embedded Linux). But the layer above that is still under construction. What is needed is a platform that will allow you to build business-level software components and integrate them on the device and/or even reuse them over device boundaries.<br /><br />Interesting efforts in this context are ...<br /><ul><li><a href="http://www.osgi.org/Main/HomePage">OSGi</a> - a component deployment platform for embedded devices for components and services implemented in JAVA</li><li>The Virtual Function Bus (VFB) in <a href="http://www.autosar.org">AUTOSAR</a> - a common software infrastructure  for automotive systems of all vehicle domains based on standardized interfaces</li><li>Various embedded software engineering platforms for mobile devices like <a href="http://www.limofoundation.org/">LiMo</a>, <a href="http://www.moblin.org/">Moblin</a> and Android<br /></li></ul>Complementary to these efforts you need a way to distribute/access these components over process or even hardware boundaries. The IONA Professional Services Organization has implemented a solution called Artix/E, that provides a transport-independent, high-performance, component platform for the embedded market.<br /><br />Can we avoid the embedded software crisis? Yes, we can! <a href="http://web.me.com/potsuntoinu/Mr_Lee/SOA_DNA/SOA_DNA.html">Check it out</a>.

  

      </main>
      
  

  </div>
  </body>
</html>