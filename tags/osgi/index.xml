<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>OSGi on tedn.life</title>
    <link>http://tedn.life/tags/osgi/</link>
    <description>Recent content in OSGi on tedn.life</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Sun, 16 Aug 2020 16:11:59 +0100</lastBuildDate>
    <atom:link href="http://tedn.life/tags/osgi/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>A starting point for ... Apache Felix, OSGi, Scala, Sbt</title>
      <link>http://tedn.life/2012/09/16/a-starting-point-for-...-apache-felix-osgi-scala-sbt/</link>
      <pubDate>Sun, 16 Sep 2012 00:00:00 +0000</pubDate>
      <guid>http://tedn.life/2012/09/16/a-starting-point-for-...-apache-felix-osgi-scala-sbt/</guid>
      <description>It is not a secret ...&lt;br /&gt;&lt;br /&gt;I like &lt;a href=&#34;http://blog.tritsch.org/2010/04/managing-complexity-with-osgi-in-and.html&#34; target=&#34;_blank&#34;&gt;OSGi&lt;/a&gt; and Scala ... and therefore it was only a question of time until I started to wonder, if there is anything that would prevent me from using OSGi from/with Scala. The short answer and the good news is ... nothing.&lt;br /&gt;&lt;br /&gt;I just &lt;a href=&#34;https://github.com/rolandtritsch/apache-felix-scala-tutorial&#34; target=&#34;_blank&#34;&gt;checked in&lt;/a&gt; my port of the original &lt;a href=&#34;http://felix.apache.org/site/apache-felix-osgi-tutorial.html&#34; target=&#34;_blank&#34;&gt;Apache Felix Tutorial&lt;/a&gt; to Scala. As mentioned in the README I do not want to claim that this boilerplate code, but it is a working development environment that you can use as a starting point for your own experiments.</description>
    </item>
    <item>
      <title>Managing complexity with OSGi - In bundles and between bundles</title>
      <link>http://tedn.life/2010/04/22/managing-complexity-with-osgi-in-bundles-and-between-bundles/</link>
      <pubDate>Thu, 22 Apr 2010 00:00:00 +0000</pubDate>
      <guid>http://tedn.life/2010/04/22/managing-complexity-with-osgi-in-bundles-and-between-bundles/</guid>
      <description>&lt;div style=&#34;text-align: left;&#34;&gt;Right now the &lt;a href=&#34;http://sp.brandvis.com/&#34;&gt;Brandvis SelectPortal system&lt;/a&gt; is based on Microsoft .NET and we constantly improve it and add features. While we do this we also constantly refactor the system to eliminate complexity to make it easier to maintain/extend.&lt;/div&gt;&lt;div style=&#34;text-align: left;&#34;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;Triggered by this work and triggered by a talk on reuse of &lt;a href=&#34;http://www.osgi.org/&#34;&gt;OSGi&lt;/a&gt; bundles that I attended a couple of years ago, I started to think about complexity again. The main conclusion of that thought process is that there is probably an optimal (means minimal) complexity for any given system.&lt;/div&gt;&lt;div style=&#34;text-align: center;&#34;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;To get to that optimal level of complexity you constantly refactor the system (because there is no chance in hell that you will get it right the first time around by thinking about it and then implementing it) and change the granularity/size of your reusable software artifacts (classes, bundles, services).&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;Getting the granularity/size (and the responsibilities) of a reusable software artifact right, is probably the holy-grail of software engineering and there is no easy answer, because if you cut it too small and build the system from a lot of very simple, small software artifacts the complexity and dependencies and relationships between the artifacts get out of hand. Going the other way you can try to reduce the complexity of the system, by building it from larger software artifacts, but then these artifacts itself will become more complex.&lt;br /&gt;&lt;br /&gt;&lt;div class=&#34;separator&#34; style=&#34;clear: both; text-align: center;&#34;&gt;&lt;a href=&#34;http://1.bp.blogspot.com/-vFsfIMARfBI/UFY2VOueY5I/AAAAAAAAAC4/QnejRn1l8hw/s1600/OSGiBundles.jpg&#34; imageanchor=&#34;1&#34; style=&#34;margin-left: 1em; margin-right: 1em;&#34;&gt;&lt;img border=&#34;0&#34; height=&#34;480&#34; src=&#34;http://1.bp.blogspot.com/-vFsfIMARfBI/UFY2VOueY5I/AAAAAAAAAC4/QnejRn1l8hw/s640/OSGiBundles.jpg&#34; width=&#34;640&#34; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;br /&gt;&lt;/div&gt;&lt;br /&gt;&lt;div&gt;&lt;div style=&#34;text-align: center;&#34;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;That means that in any case you need to build your system on a software platform that allows you to iterate on getting the granularity of the software artifacts right. I believe OSGi is such a platform.&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt;</description>
    </item>
    <item>
      <title>ACCU 2009 - Slides are available</title>
      <link>http://tedn.life/2009/06/20/accu-2009-slides-are-available/</link>
      <pubDate>Sat, 20 Jun 2009 00:00:00 +0000</pubDate>
      <guid>http://tedn.life/2009/06/20/accu-2009-slides-are-available/</guid>
      <description>A couple of weeks ago I attended &lt;a href=&#34;http://accu.org/index.php/conferences&#34;&gt;ACCU 2009&lt;/a&gt; to deliver a talk on &#34;&lt;a href=&#34;http://accu.org/index.php/conferences/accu_conference_2009/accu2009_sessions#RESTful%20Services%20and%20Distributed%20OSGi%20-%20Friends%20or%20Foes&#34;&gt;RESTful Services and Distributed OSGi - Friends or Foes&lt;/a&gt;&#34; and &#34;&lt;a href=&#34;http://accu.org/index.php/conferences/accu_conference_2009/accu2009_sessions#AJAX%20for%20Mobile%20Devices%20-%20Using%20Apache%20Projects%20to%20get%20the%20job%20done&#34;&gt;AJAX for Mobile Devices - Using Apache Projects to get the job done&lt;/a&gt;&#34;. The conference was very well organized (thanks Giovanni) and took place in the beautiful city of Oxford. The format (keynote presentations and smaller breakout sessions) allowed for a good mix of thought-provoking presentations and good discussions. The audience was made up from very-experienced software-engineers and no-BS project-mangers.&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;My most favorite presentation/keynote was delivered by &lt;a href=&#34;http://accu.org/index.php/conferences/accu_conference_2009/accu2009_sessions#The%20Benefits%20of%20Abstraction%20in%20Patterns&#34;&gt;Linda Rising (The Benefits of Abstraction in Patterns)&lt;/a&gt;. She talked about the potential of patterns going beyond the ability to put structure into the domain of software engineering.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;I am looking forward to learn about the agenda for next year.&lt;/div&gt;</description>
    </item>
    <item>
      <title>FUSEforge Lightsaber/Lightsabre - Research on Asynchronous Distributed OSGi (for Jedi&#39;s :))</title>
      <link>http://tedn.life/2009/06/09/fuseforge-lightsaber/lightsabre-research-on-asynchronous-distributed-osgi-for-jedis/</link>
      <pubDate>Tue, 09 Jun 2009 00:00:00 +0000</pubDate>
      <guid>http://tedn.life/2009/06/09/fuseforge-lightsaber/lightsabre-research-on-asynchronous-distributed-osgi-for-jedis/</guid>
      <description>The &lt;a href=&#34;http://cxf.apache.org/distributed-osgi.html&#34;&gt;Distributed OSGi spec (RFC 119)&lt;/a&gt; is coming along nicely, means now might be a good time to raise the head and start to think about what might come next. A couple of month ago &lt;a href=&#34;http://coderthoughts.blogspot.com/&#34;&gt;David&lt;/a&gt;, &lt;a href=&#34;http://romanroe.blogspot.com&#34;&gt;Roman&lt;/a&gt; and &lt;a href=&#34;http://www.tritsch.org/&#34;&gt;myself&lt;/a&gt; got together and concluded to set up a research project on the alternatives available to potentially extend the Distributed OSGi spec with some asynchronous messaging concepts/capabilities.&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;The research is still ongoing, but the intermediate results (including a first demo!!!) are now available on &lt;a href=&#34;http://fusesource.com/forge/&#34;&gt;FUSEforge&lt;/a&gt; (Project &lt;a href=&#34;http://fusesource.com/forge/projects/LIGHTSABRE&#34;&gt;Lightsabre&lt;/a&gt;). &lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;The demo will also be presented at &lt;a href=&#34;http://www.osgi.org/DevConEurope2009/HomePage&#34;&gt;OSGi DevCon Europe&lt;/a&gt;. Maybe (another) reason to attend. Enjoy and stay tuned.&lt;/div&gt;</description>
    </item>
    <item>
      <title>Embedded Software Engineering - Can we avoid another software crisis</title>
      <link>http://tedn.life/2008/08/12/embedded-software-engineering-can-we-avoid-another-software-crisis/</link>
      <pubDate>Tue, 12 Aug 2008 00:00:00 +0000</pubDate>
      <guid>http://tedn.life/2008/08/12/embedded-software-engineering-can-we-avoid-another-software-crisis/</guid>
      <description>The term &#34;&lt;a href=&#34;http://en.wikipedia.org/wiki/Software_crisis&#34;&gt;software crisis&lt;/a&gt;&#34; was coined 1968  by F.L. Bauer during the first NATO Software Engineering Conference  in Garmisch, Germany and was used by Dijkstra in his very famous lecture on &#34;The humble programmer&#34;:&lt;br /&gt;&lt;br /&gt; &lt;span style=&#34;font-style: italic;&#34;&gt;    [The major cause of the software crisis is] that the machines have become several orders of magnitude more powerful! To put it quite bluntly: as long as there were no machines, programming was no problem at all; when we had a few weak computers, programming became a mild problem, and now we have gigantic computers, programming has become an equally gigantic problem. &lt;/span&gt;&lt;br /&gt;&lt;br /&gt;             – &lt;cite&gt;Edsger Dijkstra, The Humble Programmer&lt;br /&gt;&lt;/cite&gt;&lt;br /&gt;Right now there are lots of people who are saying two things: First, embedded devices and embedded software will change and transform our way of life in a similar or even stronger way than the arrival of the internet and second, the resulting software engineering challenges are huge.&#xA;&#xA;&lt;br /&gt;&lt;br /&gt;There are a lot of drivers/trends behind this, but two of the more critical ones are the &lt;a href=&#34;http://www.sdtimes.com/SearchResult/31938&#34;&gt;arrival of multi-core processor architectures&lt;/a&gt; for embedded devices and the resulting increase in processing power that comes with it (see quote above :)). And secondly the increasing demand to make embedded devices talk to each other (e.g. make Electronic Control Units (ECUs) on the car talk to each other and then make cars talk to each other).&lt;br /&gt;&lt;br /&gt;The lack of abstraction that we have in embedded software engineering makes more than 50% of all embedded software projects being later, over budget or not deliver on expectations.&lt;br /&gt;&lt;br /&gt;This sounds and looks like a first class  software (engineering) crisis. What do we do?&lt;br /&gt;&lt;br /&gt;Killing the problem with people (e.g. throw more people at the problem) is a very popular approach, especially with the emergence of cheap off-shore development centers in India and other places, but creates a huge liability, because over time it does not scale very well and the management and maintenance burden has the potential to become an even bigger problem.&lt;br /&gt;&lt;br /&gt;More thoughtful approaches first segment the embedded market from a requirements point of view and then look for much more systematic approaches to address the requirements in the given segment. One way to segment the market would be along the lines of the real-time requirements. Working assumption would be that there is a hard real-time market, a soft real-time market and an embedded market (no real-time requirements, but the software must run on devices with limited CPU and memory capabilities).&lt;br /&gt;&lt;br /&gt;The segment with the strongest growth is the last one. Addressing the software engineering issues in this segment will give us the biggest bang for the buck.&lt;br /&gt;&lt;br /&gt;One way to go about it is to use existing approaches that have (kind of) worked for the first two (real-time) segments and also use them in the embedded space, e.g. using integrated tool-chains to generate a lot of the source code (also known as Model-Driven Software-Development (MDSD)). This gives you good initial results in terms of productivity, but has the potential to create hard to maintain, monolithic, tightly-coupled monster systems.&lt;br /&gt;&lt;br /&gt;The most &lt;a href=&#34;http://www.mil-embedded.com/articles/id/?3046&#34;&gt;promising approach&lt;/a&gt; right now is to introduce the idea of Software Product Lines (SPLs) to the domain of embedded software engineering and combine it with MDSD. This will give you the productivity gains you are looking for, but will also allow you to enforce a/the necessary level of reuse to ensure the long-term maintainability of the system.&lt;br /&gt;&lt;br /&gt;In that context abstractions become pivotal. Without abstractions there is no way to create good boundaries for reuse. The first level of abstraction is the operating system and here is good news, because more and more embedded systems are based on standard operating systems (e.g. embedded Linux). But the layer above that is still under construction. What is needed is a platform that will allow you to build business-level software components and integrate them on the device and/or even reuse them over device boundaries.&lt;br /&gt;&lt;br /&gt;Interesting efforts in this context are ...&lt;br /&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;http://www.osgi.org/Main/HomePage&#34;&gt;OSGi&lt;/a&gt; - a component deployment platform for embedded devices for components and services implemented in JAVA&lt;/li&gt;&lt;li&gt;The Virtual Function Bus (VFB) in &lt;a href=&#34;http://www.autosar.org&#34;&gt;AUTOSAR&lt;/a&gt; - a common software infrastructure  for automotive systems of all vehicle domains based on standardized interfaces&lt;/li&gt;&lt;li&gt;Various embedded software engineering platforms for mobile devices like &lt;a href=&#34;http://www.limofoundation.org/&#34;&gt;LiMo&lt;/a&gt;, &lt;a href=&#34;http://www.moblin.org/&#34;&gt;Moblin&lt;/a&gt; and Android&lt;br /&gt;&lt;/li&gt;&lt;/ul&gt;Complementary to these efforts you need a way to distribute/access these components over process or even hardware boundaries. The IONA Professional Services Organization has implemented a solution called Artix/E, that provides a transport-independent, high-performance, component platform for the embedded market.&lt;br /&gt;&lt;br /&gt;Can we avoid the embedded software crisis? Yes, we can! &lt;a href=&#34;http://web.me.com/potsuntoinu/Mr_Lee/SOA_DNA/SOA_DNA.html&#34;&gt;Check it out&lt;/a&gt;.</description>
    </item>
    <item>
      <title>2008 OSGi Community Event - talking about trains</title>
      <link>http://tedn.life/2008/06/23/2008-osgi-community-event-talking-about-trains/</link>
      <pubDate>Mon, 23 Jun 2008 00:00:00 +0000</pubDate>
      <guid>http://tedn.life/2008/06/23/2008-osgi-community-event-talking-about-trains/</guid>
      <description>Two weeks ago I attended the &lt;a href=&#34;http://www.osgi.org/CommunityEvent2008/HomePage&#34;&gt;OSGi Community Event&lt;/a&gt; in Berlin.&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;One of the presentations was from Deutsche Bahn about their new &lt;a href=&#34;http://www.osgi.org/wiki/uploads/CommunityEvent2008/08_Praes_Berlin_OSGi-Kongress%20V04.pdf&#34;&gt;Mobile Integration Platform&lt;/a&gt; (MIP). It was not only in this presentation that I felt that OSGi has become the ICE of deployment platforms. A 300 km/h high-speed trend/train with a lot of momentum. Think about it: Do you want to be on the train or in front of it.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;There were lots of good and interesting &lt;a href=&#34;http://www.osgi.org/CommunityEvent2008/Program&#34;&gt;presentations&lt;/a&gt;. Here are a couple of highlights ...&#xA;&#xA;&lt;/div&gt;&lt;div&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;http://www.osgi.org/wiki/uploads/CommunityEvent2008/08_Praes_Berlin_OSGi-Kongress%20V04.pdf&#34;&gt;Deutsche Bahn&lt;/a&gt;: Mobile Integration Platform - using OSGi to bridge the gap between the lifecyle of a vehicle (e.g. train) and software (e.g. an application). Vehicles have a much longer lifecycle than software. A huge challenge with a lot of opportunity, but only the tip of the iceberg. After you have tapped into the vehicle and can really access it (anytime, anywhere) I would predict a new dimension of integration challenges that will arise on the backend side to make all the relevant information available to the train and also to process the information that comes from the train. Interesting. Very interesting.&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;http://www.osgi.org/wiki/uploads/CommunityEvent2008/02_Keynote%20PM%20master.pdf&#34;&gt;Deutsche Telekom/T-Labs&lt;/a&gt;: &#34;We catalyze technology-based innovations&#34; - very good presentation on the role of OSGi as an enabler for innovation. &lt;a href=&#34;http://www.tritsch.org/Blog/2008/05/mobile-monday-in-belfast-webservices-to.html&#34;&gt;As previously discussed&lt;/a&gt;, currently (Mobile) Telekom Operators look for ways to maintain or even increase their relevance in the value-chain. If they do nothing they might turn into (more or less) value-less bit-pipes. OSGi is the kind/type of technology that will allow them to innovate faster and to roll-out these innovations to the customers, much faster than previously possible.&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;http://www.osgi.org/wiki/uploads/CommunityEvent2008/12_bostrom.pdf&#34;&gt;Sprint&lt;/a&gt;: Titan - the next generation mobile service platform (&#34;Browser with AJAX is JUST NOT ENOUGH&#34;). Earlier this year Sprint released its new mobile software development platform called &lt;a href=&#34;http://developer.sprint.com/site/global/develop/technologies/sprint_titan/p_sprint_titan.jsp&#34;&gt;Titan&lt;/a&gt;.  This platform is a show-case, how Java technologies can come together to create a portable mobile software engineering platform that can bring applications to a wide variety of devices. OSGi is clearly a key enabler to make this happen.&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;div&gt;BTW, this does not mean that the presentations I am not mentioning were not interesting. It means that I had to step out of the room for a meeting or a call and missed that specific presentation :).&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;Last but not least, we (IONA :)) showed a demo of the current status of the &lt;a href=&#34;http://blogs.iona.com/newcomer/archives/000569.html&#34;&gt;Distributed OSGi Reference Implementation&lt;/a&gt;. Overall a very energizing, educational, interesting event. I recommend you put it into your calendar for next year :).&lt;/div&gt;</description>
    </item>
    <item>
      <title>Software Engineering Radio - talking about OSGi, Rest, Opensource, ...</title>
      <link>http://tedn.life/2008/06/23/software-engineering-radio-talking-about-osgi-rest-opensource-.../</link>
      <pubDate>Mon, 23 Jun 2008 00:00:00 +0000</pubDate>
      <guid>http://tedn.life/2008/06/23/software-engineering-radio-talking-about-osgi-rest-opensource-.../</guid>
      <description>In the last four weeks a lot of people asked me about this &#34;show&#34; I am listening to on my way to work. It is called &lt;a href=&#34;http://www.se-radio.net/&#34;&gt;Software Engineering Radio&lt;/a&gt; and talks about trends and technologies in Software Engineering (&lt;a href=&#34;http://www.se-radio.net/podcast/2007-12/episode-80-osgi-peter-kriens-and-bj-hargrave&#34;&gt;OSGi&lt;/a&gt;, &lt;a href=&#34;http://www.se-radio.net/podcast/2008-05/episode-98-stefan-tilkov-rest&#34;&gt;Rest&lt;/a&gt;, &lt;a href=&#34;http://www.se-radio.net/podcast/2008-04/episode-94-open-source-business-models-dirk-riehle&#34;&gt;Opensource&lt;/a&gt;, ...). I was told that one of the next issues will be an interview with Peter Kriens on the current state of affairs with respect to OSGi.&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;Check it out. &lt;/div&gt;</description>
    </item>
  </channel>
</rss>
