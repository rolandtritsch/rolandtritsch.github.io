<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Embedded on tedn.life</title>
    <link>http://tedn.life/tags/embedded/</link>
    <description>Recent content in Embedded on tedn.life</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Sun, 16 Aug 2020 16:11:59 +0100</lastBuildDate>
    <atom:link href="http://tedn.life/tags/embedded/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Scala on the Pebble - Exploring SDK 2.0 ...</title>
      <link>http://tedn.life/2014/02/06/scala-on-the-pebble-exploring-sdk-2.0-.../</link>
      <pubDate>Thu, 06 Feb 2014 00:00:00 +0000</pubDate>
      <guid>http://tedn.life/2014/02/06/scala-on-the-pebble-exploring-sdk-2.0-.../</guid>
      <description>... just kidding :).&lt;br /&gt;&lt;br /&gt;Reality is ... triggered by the &lt;a href=&#34;https://developer.getpebble.com/2/&#34;&gt;release of the Pebble SDK 2.0&lt;/a&gt; on Feb., 3rd (iOS only, more on this later) and after more than 20 years of JVM based software development I willingful decided to write some C code again!!!&lt;br /&gt;&lt;br /&gt;&lt;div class=&#34;separator&#34; style=&#34;clear: both; text-align: center;&#34;&gt;&lt;/div&gt;&lt;div class=&#34;separator&#34; style=&#34;clear: both; text-align: center;&#34;&gt;&lt;a href=&#34;http://2.bp.blogspot.com/-NHELCe3_H7o/UvNHXk3ObfI/AAAAAAAAA3g/NFmAaAqaoHw/s1600/2014-02-06+08.24.03.jpg&#34; imageanchor=&#34;1&#34; style=&#34;margin-left: 1em; margin-right: 1em;&#34;&gt;&lt;img border=&#34;0&#34; src=&#34;http://2.bp.blogspot.com/-NHELCe3_H7o/UvNHXk3ObfI/AAAAAAAAA3g/NFmAaAqaoHw/s1600/2014-02-06+08.24.03.jpg&#34; height=&#34;320&#34; width=&#34;181&#34; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;br /&gt;&lt;br /&gt;And I liked it. Mainly because of &lt;a href=&#34;https://cloudpebble.net/ide/project/32563&#34;&gt;CloudPebble&lt;/a&gt;. As pointed out &lt;a href=&#34;http://blog.tritsch.org/2014/01/scala-on-android-start.html&#34;&gt;here&lt;/a&gt;, setting up a software development environment can be a daunting task. Not so with CloudPebble. Long term I will probably install the SDK, but to get something simple done fast and to experiment with the SDK and its capabilities it is a very interesting approach. Not to mention that it works using &lt;a href=&#34;http://blog.tritsch.org/2014/01/scala-on-chromebook-yes-we-can.html&#34;&gt;my ChromeBook&lt;/a&gt;.&#xA;&#xA;&lt;br /&gt;&lt;br /&gt;&lt;div class=&#34;separator&#34; style=&#34;clear: both; text-align: center;&#34;&gt;&lt;object width=&#34;320&#34; height=&#34;266&#34; class=&#34;BLOGGER-youtube-video&#34; classid=&#34;clsid:D27CDB6E-AE6D-11cf-96B8-444553540000&#34; codebase=&#34;http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=6,0,40,0&#34; data-thumbnail-src=&#34;https://i1.ytimg.com/vi/dNG7xWBX0io/0.jpg&#34;&gt;&lt;param name=&#34;movie&#34; value=&#34;https://www.youtube.com/v/dNG7xWBX0io?version=3&amp;f=user_uploads&amp;c=google-webdrive-0&amp;app=youtube_gdata&#34; /&gt;&lt;param name=&#34;bgcolor&#34; value=&#34;#FFFFFF&#34; /&gt;&lt;param name=&#34;allowFullScreen&#34; value=&#34;true&#34; /&gt;&lt;embed width=&#34;320&#34; height=&#34;266&#34;  src=&#34;https://www.youtube.com/v/dNG7xWBX0io?version=3&amp;f=user_uploads&amp;c=google-webdrive-0&amp;app=youtube_gdata&#34; type=&#34;application/x-shockwave-flash&#34; allowfullscreen=&#34;true&#34;&gt;&lt;/embed&gt;&lt;/object&gt;&lt;/div&gt;&lt;br /&gt;As mentioned in the Video, at the current point in time, because the Android SDK is still work in progress, there are a couple of things that you need to do to make this work. Mainly you need to &lt;a href=&#34;https://developer.getpebble.com/2/getting-started/&#34;&gt;install the Pebble 2.0 App on your phone and you then need to upgrade the firmware on your Watch to 2.0&lt;/a&gt;. What worked for me was to download the .abk and the .pbz files to my phone, open the file manager of choice and then installing them by first opening the apk and then the pbz file. With that you should be all set.&lt;br /&gt;&lt;br /&gt;&lt;div class=&#34;separator&#34; style=&#34;clear: both; text-align: center;&#34;&gt;&lt;a href=&#34;http://1.bp.blogspot.com/-OkRo7l0Kh_E/UvNKxYFxcPI/AAAAAAAAA3w/HT3kewuLJwg/s1600/2014-02-06+05.52.35-2.jpg&#34; imageanchor=&#34;1&#34; style=&#34;margin-left: 1em; margin-right: 1em;&#34;&gt;&lt;img border=&#34;0&#34; src=&#34;http://1.bp.blogspot.com/-OkRo7l0Kh_E/UvNKxYFxcPI/AAAAAAAAA3w/HT3kewuLJwg/s1600/2014-02-06+05.52.35-2.jpg&#34; height=&#34;320&#34; width=&#34;181&#34; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;br /&gt;&lt;br /&gt;To get started I used a &lt;a href=&#34;http://ninedof.wordpress.com/2013/12/02/pebble-sdk-2-0-tutorial-1-your-first-watchapp/&#34;&gt;tutorial&lt;/a&gt; and modified it a little bit (playing around with fonts). I also hooked up my CloudPebble account to my GitHub account and the final version of the source code is available &lt;a href=&#34;https://github.com/rolandtritsch/pebble-helloworld&#34;&gt;there&lt;/a&gt;.&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;</description>
    </item>
    <item>
      <title>Embedded Software Engineering - Can we avoid another software crisis</title>
      <link>http://tedn.life/2008/08/12/embedded-software-engineering-can-we-avoid-another-software-crisis/</link>
      <pubDate>Tue, 12 Aug 2008 00:00:00 +0000</pubDate>
      <guid>http://tedn.life/2008/08/12/embedded-software-engineering-can-we-avoid-another-software-crisis/</guid>
      <description>The term &#34;&lt;a href=&#34;http://en.wikipedia.org/wiki/Software_crisis&#34;&gt;software crisis&lt;/a&gt;&#34; was coined 1968  by F.L. Bauer during the first NATO Software Engineering Conference  in Garmisch, Germany and was used by Dijkstra in his very famous lecture on &#34;The humble programmer&#34;:&lt;br /&gt;&lt;br /&gt; &lt;span style=&#34;font-style: italic;&#34;&gt;    [The major cause of the software crisis is] that the machines have become several orders of magnitude more powerful! To put it quite bluntly: as long as there were no machines, programming was no problem at all; when we had a few weak computers, programming became a mild problem, and now we have gigantic computers, programming has become an equally gigantic problem. &lt;/span&gt;&lt;br /&gt;&lt;br /&gt;             â€“ &lt;cite&gt;Edsger Dijkstra, The Humble Programmer&lt;br /&gt;&lt;/cite&gt;&lt;br /&gt;Right now there are lots of people who are saying two things: First, embedded devices and embedded software will change and transform our way of life in a similar or even stronger way than the arrival of the internet and second, the resulting software engineering challenges are huge.&#xA;&#xA;&lt;br /&gt;&lt;br /&gt;There are a lot of drivers/trends behind this, but two of the more critical ones are the &lt;a href=&#34;http://www.sdtimes.com/SearchResult/31938&#34;&gt;arrival of multi-core processor architectures&lt;/a&gt; for embedded devices and the resulting increase in processing power that comes with it (see quote above :)). And secondly the increasing demand to make embedded devices talk to each other (e.g. make Electronic Control Units (ECUs) on the car talk to each other and then make cars talk to each other).&lt;br /&gt;&lt;br /&gt;The lack of abstraction that we have in embedded software engineering makes more than 50% of all embedded software projects being later, over budget or not deliver on expectations.&lt;br /&gt;&lt;br /&gt;This sounds and looks like a first class  software (engineering) crisis. What do we do?&lt;br /&gt;&lt;br /&gt;Killing the problem with people (e.g. throw more people at the problem) is a very popular approach, especially with the emergence of cheap off-shore development centers in India and other places, but creates a huge liability, because over time it does not scale very well and the management and maintenance burden has the potential to become an even bigger problem.&lt;br /&gt;&lt;br /&gt;More thoughtful approaches first segment the embedded market from a requirements point of view and then look for much more systematic approaches to address the requirements in the given segment. One way to segment the market would be along the lines of the real-time requirements. Working assumption would be that there is a hard real-time market, a soft real-time market and an embedded market (no real-time requirements, but the software must run on devices with limited CPU and memory capabilities).&lt;br /&gt;&lt;br /&gt;The segment with the strongest growth is the last one. Addressing the software engineering issues in this segment will give us the biggest bang for the buck.&lt;br /&gt;&lt;br /&gt;One way to go about it is to use existing approaches that have (kind of) worked for the first two (real-time) segments and also use them in the embedded space, e.g. using integrated tool-chains to generate a lot of the source code (also known as Model-Driven Software-Development (MDSD)). This gives you good initial results in terms of productivity, but has the potential to create hard to maintain, monolithic, tightly-coupled monster systems.&lt;br /&gt;&lt;br /&gt;The most &lt;a href=&#34;http://www.mil-embedded.com/articles/id/?3046&#34;&gt;promising approach&lt;/a&gt; right now is to introduce the idea of Software Product Lines (SPLs) to the domain of embedded software engineering and combine it with MDSD. This will give you the productivity gains you are looking for, but will also allow you to enforce a/the necessary level of reuse to ensure the long-term maintainability of the system.&lt;br /&gt;&lt;br /&gt;In that context abstractions become pivotal. Without abstractions there is no way to create good boundaries for reuse. The first level of abstraction is the operating system and here is good news, because more and more embedded systems are based on standard operating systems (e.g. embedded Linux). But the layer above that is still under construction. What is needed is a platform that will allow you to build business-level software components and integrate them on the device and/or even reuse them over device boundaries.&lt;br /&gt;&lt;br /&gt;Interesting efforts in this context are ...&lt;br /&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;http://www.osgi.org/Main/HomePage&#34;&gt;OSGi&lt;/a&gt; - a component deployment platform for embedded devices for components and services implemented in JAVA&lt;/li&gt;&lt;li&gt;The Virtual Function Bus (VFB) in &lt;a href=&#34;http://www.autosar.org&#34;&gt;AUTOSAR&lt;/a&gt; - a common software infrastructure  for automotive systems of all vehicle domains based on standardized interfaces&lt;/li&gt;&lt;li&gt;Various embedded software engineering platforms for mobile devices like &lt;a href=&#34;http://www.limofoundation.org/&#34;&gt;LiMo&lt;/a&gt;, &lt;a href=&#34;http://www.moblin.org/&#34;&gt;Moblin&lt;/a&gt; and Android&lt;br /&gt;&lt;/li&gt;&lt;/ul&gt;Complementary to these efforts you need a way to distribute/access these components over process or even hardware boundaries. The IONA Professional Services Organization has implemented a solution called Artix/E, that provides a transport-independent, high-performance, component platform for the embedded market.&lt;br /&gt;&lt;br /&gt;Can we avoid the embedded software crisis? Yes, we can! &lt;a href=&#34;http://web.me.com/potsuntoinu/Mr_Lee/SOA_DNA/SOA_DNA.html&#34;&gt;Check it out&lt;/a&gt;.</description>
    </item>
  </channel>
</rss>
