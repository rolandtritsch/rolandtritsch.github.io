<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Haskell on tedn.life</title>
    <link>http://tedn.life/tags/haskell/</link>
    <description>Recent content in Haskell on tedn.life</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Wed, 02 Jun 2021 07:15:02 +0100</lastBuildDate>
    <atom:link href="http://tedn.life/tags/haskell/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Haskell &#43; Beam = Hamler (III)</title>
      <link>http://tedn.life/2021/02/01/haskell--beam-hamler-iii/</link>
      <pubDate>Mon, 01 Feb 2021 00:00:00 +0000</pubDate>
      <guid>http://tedn.life/2021/02/01/haskell--beam-hamler-iii/</guid>
      <description>&lt;p&gt;Here comes part III of the &lt;a href=&#34;https://tedn.life/2020/12/15/haskell-beam-hamler-i/&#34;&gt;Hamler blog post series&lt;/a&gt; &amp;hellip;&lt;/p&gt;&#xA;&lt;p&gt;One of the observations was that for/on Day21 hamler ~6000 times slower than haskell, where in general we where able to see that it was 5-20 times slower.&lt;/p&gt;&#xA;&lt;p&gt;Just looked into this a little bit and there is good news and bad news. The good news is I found something.&lt;/p&gt;&#xA;&lt;p&gt;I can make the hamer solution run 10 times faster by changing the implementation of part1 from &amp;hellip;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Haskell &#43; Beam = Hamler (II)</title>
      <link>http://tedn.life/2021/01/18/haskell--beam-hamler-ii/</link>
      <pubDate>Mon, 18 Jan 2021 00:00:00 +0000</pubDate>
      <guid>http://tedn.life/2021/01/18/haskell--beam-hamler-ii/</guid>
      <description>&lt;p&gt;Here comes part II of the &lt;a href=&#34;https://tedn.life/2020/12/15/haskell-beam-hamler-i/&#34;&gt;Hamler blog post series&lt;/a&gt; &amp;hellip;&lt;/p&gt;&#xA;&lt;p&gt;For this year&amp;rsquo;s &lt;a href=&#34;https://adventofcode.com/2020&#34;&gt;Advent-of-Code&lt;/a&gt; I wanted to take a look at &lt;a href=&#34;https://www.hamler-lang.org/&#34;&gt;Hamler&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;I just finished implementing all of the part-1 solutions in &lt;a href=&#34;https://github.com/rolandtritsch/hamler-aoc-2020&#34;&gt;Hamler&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;img src=&#34;http://tedn.life/images/2021-01-18-hamler-aoc-II/aoc-day25.png&#34; style=&#34;float:right&#34; width=&#34;50%&#34; hspace=&#34;1%&#34; vspace=&#34;1%&#34;/&gt;&#xA;&lt;p&gt;I had to skip Day 20 (the seamonster), because Hamler only supports a very small/limited number of packages, which means I would have needed to write a lot of code before I would have been able to tackle the actual problem.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Haskell &#43; Beam = Hamler (I)</title>
      <link>http://tedn.life/2020/12/15/haskell--beam-hamler-i/</link>
      <pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate>
      <guid>http://tedn.life/2020/12/15/haskell--beam-hamler-i/</guid>
      <description>&lt;p&gt;Hamler Blog Post Series &amp;hellip;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Hamler (I) - First week (this post)&lt;/li&gt;&#xA;&lt;li&gt;Hamler (&lt;a href=&#34;https://tedn.life/2021/01/18/haskell-beam-hamler-ii/&#34;&gt;II&lt;/a&gt;) - All solutions for part 1 (in Hamler and Haskell)&lt;/li&gt;&#xA;&lt;li&gt;Hamler (&lt;a href=&#34;https://tedn.life/2021/02/01/haskell-beam-hamler-iii/&#34;&gt;III&lt;/a&gt;) - Making Day21 10 times faster&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;What&amp;rsquo;s at the intersection of &lt;a href=&#34;https://www.haskell.org/&#34;&gt;Haskell&lt;/a&gt;, the Erlang &lt;a href=&#34;https://en.wikipedia.org/wiki/BEAM_(Erlang_virtual_machine)&#34;&gt;Beam&lt;/a&gt;/&lt;a href=&#34;http://erlang.org/doc/system_architecture_intro/sys_arch_intro.html&#34;&gt;OTP&lt;/a&gt; and the &lt;a href=&#34;https://adventofcode.com&#34;&gt;Advent-of-Code&lt;/a&gt;?&lt;/p&gt;&#xA;&lt;p&gt;Yes, right: &lt;a href=&#34;https://www.hamler-lang.org&#34;&gt;Hamler&lt;/a&gt;!&lt;/p&gt;&#xA;&lt;p&gt;Hamler is a Haskell-like language that runs on the Erlang Beam/OTP.&lt;/p&gt;&#xA;&lt;p&gt;At Community we are big Beam/OTP fans (because we like highly-scalable and highly-available shared nothing micro-services systems). Our entire backend runs on the Beam (written in Elixir).&lt;/p&gt;</description>
    </item>
    <item>
      <title>Code Elixir LDN 2019 - 3 languages in 3 minutes</title>
      <link>http://tedn.life/2019/08/01/code-elixir-ldn-2019-3-languages-in-3-minutes/</link>
      <pubDate>Thu, 01 Aug 2019 00:00:00 +0000</pubDate>
      <guid>http://tedn.life/2019/08/01/code-elixir-ldn-2019-3-languages-in-3-minutes/</guid>
      <description>&lt;p&gt;Last week I was in London attending &lt;a href=&#34;https://codesync.global/conferences/code-elixir-ldn-2019/&#34;&gt;Code Elixir LDN 2019&lt;/a&gt; delivering a lightening talk on &lt;a href=&#34;https://github.com/rolandtritsch/elixir-ldn-2019&#34;&gt;3 languages in 3 minutes&lt;/a&gt; &amp;hellip;&lt;/p&gt;&#xA;&lt;iframe style=&#34;display:block; margin-top: 5px; margin-bottom: 10px; margin-left: auto; margin-right: auto; border:3px solid black;&#34; width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/LoTHaKhHcWY&#34; frameborder=&#34;10&#34; allow=&#34;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&#34; allowfullscreen&gt;&lt;/iframe&gt;&#xA;&lt;p&gt;This was my first Elixir conference. We had about 100 people there. The conference was very well organized. From what I can see London is one the Elixir hotspots in Europe.&lt;/p&gt;&#xA;&lt;p&gt;All of the talks where good, but a couple of them where of even better value to me personally (because I am the newbie) &amp;hellip;&lt;/p&gt;</description>
    </item>
    <item>
      <title>I love Haskell</title>
      <link>http://tedn.life/2019/04/06/i-love-haskell/</link>
      <pubDate>Sat, 06 Apr 2019 00:00:00 +0000</pubDate>
      <guid>http://tedn.life/2019/04/06/i-love-haskell/</guid>
      <description>&lt;p&gt;Over the last 2 years I did a fair bit of Haskell (after doing a fairer bit of Scala for 8 years).&lt;/p&gt;&#xA;&lt;p&gt;And I love Haskell.&lt;/p&gt;&#xA;&lt;p&gt;Don&amp;rsquo;t get me wrong: If you are tied to the JVM eco-system (and who is not these days), my opinion is that Scala is your best option to do functional programming on the JVM.&lt;/p&gt;&#xA;&lt;p&gt;At the same time writting code in Haskell feels very natural to me. And sometimes it is not the big features/capabilities that make a difference. For instance in my case (in Haskell) I like &amp;hellip;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Advent of Code ... Final cut (... and First cut :))</title>
      <link>http://tedn.life/2018/11/30/advent-of-code-...-final-cut-...-and-first-cut/</link>
      <pubDate>Fri, 30 Nov 2018 00:00:00 +0000</pubDate>
      <guid>http://tedn.life/2018/11/30/advent-of-code-...-final-cut-...-and-first-cut/</guid>
      <description>&lt;p&gt;Today &lt;a href=&#34;https://adventofcode.com&#34;&gt;Advent of Code 2018&lt;/a&gt; started &lt;a href=&#34;https://github.com/rolandtritsch/haskell-aoc-2018&#34;&gt;again&lt;/a&gt; (at 05:00am (GMT))!!!&lt;/p&gt;&#xA;&lt;p&gt;And &amp;hellip;&lt;/p&gt;&#xA;&lt;p&gt;&amp;hellip; just in time &amp;hellip;&lt;/p&gt;&#xA;&lt;p&gt;&amp;hellip; today I am also wrapping up &lt;a href=&#34;https://adventofcode.com/2017&#34;&gt;Advent of Code 2017&lt;/a&gt;!!!&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;http://tedn.life/images/2018-11-30-aoc-final/tree.png&#34; alt=&#34;Tree&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;My first implementation was (obviously) in &lt;a href=&#34;https://github.com/rolandtritsch/scala-aoc-2017&#34;&gt;Scala&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;And that one alone was interesting, because I also used &lt;a href=&#34;https://www.scalacheck.org&#34;&gt;ScalaCheck&lt;/a&gt; for property-based testing and &lt;a href=&#34;https://scalameter.github.io&#34;&gt;ScalaMeter&lt;/a&gt; to implement performance tests for all solutions.&lt;/p&gt;&#xA;&lt;p&gt;I then made the Scala code &lt;a href=&#34;https://github.com/portable-scala/sbt-crossproject&#34;&gt;cross-compile&lt;/a&gt; with &lt;a href=&#34;http://www.scala-native.org/en/v0.3.8&#34;&gt;ScalaNative&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;At the time I was also learning &lt;a href=&#34;https://kotlinlang.org&#34;&gt;Kotlin&lt;/a&gt; and spend some cycles to port the code to &lt;a href=&#34;https://github.com/rolandtritsch/kotlin-aoc-2018&#34;&gt;Kotlin&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Learn you a ... Haskell!</title>
      <link>http://tedn.life/2018/08/11/learn-you-a-...-haskell/</link>
      <pubDate>Sat, 11 Aug 2018 00:00:00 +0000</pubDate>
      <guid>http://tedn.life/2018/08/11/learn-you-a-...-haskell/</guid>
      <description>&lt;p&gt;In the last 6 month I have started to wonder.&lt;/p&gt;&#xA;&lt;p&gt;First of all &amp;hellip; I am convinced that using the concepts of functional programming will give you better results (more maintainable/changeable/extendable code). Not embracing functional programming will (sooner or later) put you (and the organisation you are leading) at a competitive disadvantage (compared to those who do).&lt;/p&gt;&#xA;&lt;p&gt;In that context I have put some time into learning more &lt;a href=&#34;https://github.com/rolandtritsch/scala-aoc-2017&#34;&gt;Scala&lt;/a&gt; (the learning never stops :)) and have also looked at &lt;a href=&#34;https://github.com/rolandtritsch/kotlin-aoc-2017&#34;&gt;Kotlin&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Category Theory for Programmers ... Reviewing THE course!</title>
      <link>http://tedn.life/2018/04/03/category-theory-for-programmers-...-reviewing-the-course/</link>
      <pubDate>Tue, 03 Apr 2018 00:00:00 +0000</pubDate>
      <guid>http://tedn.life/2018/04/03/category-theory-for-programmers-...-reviewing-the-course/</guid>
      <description>&lt;p&gt;A couple of weeks ago &lt;a href=&#34;https://www.linkedin.com/in/angelcervera&#34;&gt;Angel&lt;/a&gt; pointed me to a very nice lecture: &lt;a href=&#34;https://www.youtube.com/playlist?list=PLbgaMIhjbmEnaH_LTkxLI7FMa2HsnawM_&#34;&gt;Category Theory for Programmers&lt;/a&gt; (from/by &lt;a href=&#34;https://bartoszmilewski.com/about&#34;&gt;Bartosz Milewski&lt;/a&gt;).&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://www.linkedin.com/in/drbartosz&#34;&gt;Bartosz Milewski&lt;/a&gt; is a physisist, a &lt;a href=&#34;https://www.youtube.com/watch?v=HnnyiNKpWR8&#34;&gt;philosopher&lt;/a&gt; (on computer science and life in general :)) and runs his own company to make the world a better place by means of Category Theory and Haskell :).&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;http://tedn.life/images/2018-04-03-category-theory/monads.png&#34; alt=&#34;Monads&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;The course is long &amp;hellip;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Category Theory 1.1: Motivation and Philosophy&lt;/li&gt;&#xA;&lt;li&gt;Category Theory 1.2: What is a category?&lt;/li&gt;&#xA;&lt;li&gt;Category Theory 2.1: Functions, epimorphisms&lt;/li&gt;&#xA;&lt;li&gt;Category Theory 2.2: Monomorphisms, simple types&lt;/li&gt;&#xA;&lt;li&gt;Category Theory 3.1: Examples of categories, orders, monoids&lt;/li&gt;&#xA;&lt;li&gt;Category Theory 3.2: Kleisli category&lt;/li&gt;&#xA;&lt;li&gt;Category Theory 4.1: Terminal and initial objects&lt;/li&gt;&#xA;&lt;li&gt;Category Theory 4.2: Products&lt;/li&gt;&#xA;&lt;li&gt;Category Theory 5.1: Coproducts, sum types&lt;/li&gt;&#xA;&lt;li&gt;Category Theory 5.2: Algebraic data types&lt;/li&gt;&#xA;&lt;li&gt;Category Theory 6.1: Functors&lt;/li&gt;&#xA;&lt;li&gt;Category Theory 6.2: Functors in programming&lt;/li&gt;&#xA;&lt;li&gt;Category Theory 7.1: Functoriality, bifunctors&lt;/li&gt;&#xA;&lt;li&gt;Category Theory 7.2: Monoidal Categories, Functoriality of ADTs, Profunctors&lt;/li&gt;&#xA;&lt;li&gt;Category Theory 8.1: Function objects, exponentials&lt;/li&gt;&#xA;&lt;li&gt;Category Theory 8.2: Type algebra, Curry-Howard-Lambek isomorphism&lt;/li&gt;&#xA;&lt;li&gt;Category Theory 9.1: Natural transformations&lt;/li&gt;&#xA;&lt;li&gt;Category Theory 9.2: bicategories&lt;/li&gt;&#xA;&lt;li&gt;Category Theory 10.1: Monads&lt;/li&gt;&#xA;&lt;li&gt;Category Theory 10.2: Monoid in the category of endofunctors&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&amp;hellip; and every lecture is 45-60 mins, means you need to invest 20 hours (and it helps, if you invest 20 hours before that to learn some &lt;a href=&#34;http://haskellbook.com&#34;&gt;Haskell&lt;/a&gt;).&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
